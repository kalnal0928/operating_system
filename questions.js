const questions = [
  {
    "chapter": "5장",
    "question": "5장-1. 알고리즘 단계에 대한 설명이 아닌 것은?",
    "answer": `-알고리즘의 단계는 순서가 정해져 있음
              -알고리즘 단계들이 실행되는 방식: 순차적 구조(1, 2, 3…), 병렬구조(다중 프로세서), 원인과 결과(회로)`
  },
  {
    "chapter": "5장",
    "question": "5장-2. 알고리즘의 정의에 따르면, 프로세스는 결과 값을 생성하면서 종료해야 한다?",
    "answer": `정답: o
              종료프로세스: 결과 값을 생성하면서 종료
              비종료 프로세스(알고리즘x)-무한정 진행하는 프로세스`
  },
  {
    "chapter": "5장",
    "question": "5장-3. 어떤 복잡한 대상을 표현할 때, 잘 정의된 기초요소들의 집합을 구축하면 쉽고 정형적인 표현이 가능하다. 이 때 사용되는 기초 요소를 가리키는 용어는?p14",
    "answer": `정답: 프리미티브(primitive) `
  },
  {
    "chapter": "5장",
    "question": "5장-4. 알고리즘을 자유롭게 간략히 서술해 놓은 것으로, 자연어와 프로그래밍 언어 사이에 위치하는 것은?p16",
    "answer": `정답: 의사코드 `
  },
  {
    "chapter": "5장",
    "question": "5장-5. 의사코드 언어의 설계 원칙에 해당하지 않는 것은?",
    "answer": `•널리 사용되는 프로그래밍 언어 하나를 선택한다
                •구문규칙들을 다소완화한다.
                •일부 자연어 표현들을 허용한다.
                •일관성 있고 간결한 표기법을 사용한다.
                `
  },
  {
    "chapter": "5장",
    "question": "5장-6. 다음 구문과 관련된 의사코드 프리미티브는?p18",
    "answer": `•배정문(assignment statement) : 
                이름 = 식  
                예시) 성적 = 중간고사 + 기말고사

              •조건부선택(selection)_1 
                if(조건):  
                      활동         
                예시) if(판매액이감소하였음):
                          가격을 5%만큼 낮추어라                  
              •조건부선택(selection)_2
                if(조건):      
                      활동             
                else:             
                      활동             
                
                예) if(해당연도가윤년): 
                        1일 합계 = 합 / 366
                    else:
                        1일 합계 = 합 / 365
                      
              •반복실행(iteration)   
                while(조건):                  
                    본체
                예) while(판매할 티켓이 남아있음):
                            티켓을 판다
              •함수정의
                def 이름():
                      본체   
              •매개변수(parameter)
                def Sort(List):`
  },
  {
    "chapter": "5장", 
    "question": "5장-7. '알고리즘의 발견'과 관련없는 설명은?p30",
    "answer": `•문제를 푸는 방법을 찾는 것
              •프로그램 개발의 첫번째 단계
              •프로그램 개발 과정에서 더 어려운 작업
              •기술보다 예술에 가까움
              •방법론을 배우는 것이 아님
              •상당기간에 걸쳐 노력하며 발전시켜 나가야 하는 창의적인 능력
              •특정 방법론을 따라하도록 훈련시키는 것은 창의적 기술의 함양을 방해
              ----이제는 달라져야 하는 코딩----
              •테스트를 통과하는 정답만 있다고 믿는다
              •빨리 결과를 만드는 데만 집중한다
              •코드 품질이 나빠진다
              •피드백 연결고리가 끊어져서 개선하지 않는다
              •점수가 실력을 의미하지 못한다
              •점수와 직무 역량의 상관관계가 낮다
`
  },
  {
    "chapter": "5장",
    "question": "5장-8. 문제해결 방법 중에서, 문제의 제약조건 중 일부를 완화하고 문제를 여러 조각으로 나누어 각 조각을 풀어가는 방법론은?p29",
    "answer": `(상향식(bottom up) 방법론)`
  },
  {
    "chapter": "5장",
    "question": "5장-9. 다음 코드에 따르면, 비가 오지 않고 기온이 낮을 경우에 무엇을 하나요?",
    "answer": `예시 없음`
  },
  {
    "chapter": "5장",
    "question": "5장-10. 다음 코드를 실행한 결과, 'Hello'가 출력되는 횟수는?",
    "answer": `예시 없음`
  },
  {
    "chapter": "5장",
    "question": "5장-11. 반복 제어의 구성요소가 아닌 것은?p35",
    "answer": `•초기화: 초기상태 확립 
              •테스트: 현재 상태와 종료조건을 비교하고, 조건이 만족되면 반복종료
              •변경: 종료 조건을 향하도록 상태변화`
  },
  {
    "chapter": "5장",
    "question": "5장-12. 명령 집합을 원래 작업의 부분 작업으로서 반복하는 구조는?p43",
    "answer": `정답: 재귀(recursive)구조`
  },
  {
    "chapter": "5장",
    "question": "5장-13. 다음 중, 더 효율적인 검색 방법은?p58",
    "image": "images/5-13.png",
    "answer": `정리된 효율성 순서 (낮은 복잡도 → 높은 복잡도):??
              O(1) - 가장 효율적 (예: 해시 테이블, 스택)

              O(log n) - 이진 탐색, 트리

              O(n) - 배열, 리스트 순회

              O(n log n) - 퀵소트, 머지소트

              O(n²) - 재귀적 알고리즘, 느린 정렬
              -특정 값이 리스트 안에 들어있는지 찾을 때 : 순차검색 알고리즘
              -리스트를 알파벳 순으로 정렬할 때 : 삽입정렬 알고리즘(원소를 앞에서부터 이미 정렬된 배열과 비교하여 자신의 위치를 찾아 삽입)
              -특정한 값의 위치를 찾을 때(ex:리스트에서 John이라는 항목의 검색) : 이진 검색 알고리즘(오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾음, 중앙값 선택 -> 왼쪽 오른쪽 비교)`
  },
  {
    "chapter": "5장",
    "question": "5장-14. 그래프 모양에 따라 알고리즘의 효율성을 분류하는 표기법으로, 최악의 경우에 대한 분석은?p57",
    "answer": `정답: *빅-오 (O)	최악의 경우의 시간/공간 복잡도`
  },
  {
    "chapter": "5장",
    "question": "5장-15. 그래프 모양에 따라 알고리즘의 효율성을 분류하는 표기법으로, 최선의 경우에 대한 분석은?p57",
    "answer": `정답: 오메가 표기법 (Ω-표기법)`
  },
  {
    "chapter": "5장",
    "question": "5장-16. 그래프 모양에 따라 알고리즘의 효율성을 분류하는 표기법으로, 평균의 경우에 대한 분석은??p57",
    "answer": `정답: *쎄타 (Θ)	평균 또는 정확한 경계`
  },
  {
    "chapter": "5장",
    "question": "5장-17. 명확하고 실행 가능한 단계들의 집합단계로, 순서가 정해져 있고 종료되는 프로세스를 정의한 것은?p9",
    "answer": `알고리즘`
  },
  {
    "chapter": "6장",
    "question": "6장-1. 기계 명령을 표현하기 위한 기호 체계로, 어셈블러(assembler)라고 불리는 프로그램에 의해 기계어로 변환되는 언어는p5",
    "answer": `어셈블리 언어`
  },
  {
    "chapter": "6장",
    "question": "6장-2. 숫자들로 인코딩된 일련의 명령들로 구성된 언어로, 이해하기 어렵고, 오류 해결(디버깅) 어려운 것은?p4",
    "answer": `정답: 1세대 언어- 기계어`
  },
  {
    "chapter": "6장",
    "question": "6장-3. 3세대 언어에서 소스코드를 기계어로 번역해주는 프로그램으로, 번역된 버전은 나중에 사용하는 것은?p6",
    "answer": `정답: 컴파일러(compiler)`
  },
  {
    "chapter": "6장",
    "question": "6장-4. 3세대 언어에서 소스코드를 기계어로 번역하면서 실행하는 프로그램은?p7",
    "answer": `정답: 인터프리터(interpreter)`
  },
  {
    "chapter": "6장",
    "question": "6장-5. 프로그래밍 언어가 진보할수록, 사람이 컴퓨터의 특성을 맞춰서 코딩해야 한다?p8",
    "answer": `정답: x`
  },
  {
    "chapter": "6장",
    "question": "6장-6. 프로그램이 수행할 동작을 '일일이 지정'하는 프로그래밍 모델로, '객체'를 활용하는 모델은?",
    "answer": `정답: 객체지향 프로그래밍(oop)??`
  },
  {
    "chapter": "6장",
    "question": "6장-7. 시각적 프로그래밍 언어로, 화면 상에서 그래픽 블록을 조작하여 프로그램을 작성하는 방식은?p10",
    "answer": `정답: 블록 기반 프로그래밍`
  },
  {
    "chapter": "6장",
    "question": "6장-8. 최근 가장 핫한 프로그래밍 언어는?",
    "answer": `정답: 파이썬`
  },
  {
    "chapter": "6장",
    "question": "6장-9. 전형적인 명령형 프로그램 구성에서, 프로그램에서 사용할 용어를 '정의'하는 문장은?p14",
    "answer": `정답: 선언문
              •참고= 명령문: 알고리즘의 단계 기술
              •참고= 주석: 프로그램의 기능을 사람이 이해하도록 설명`
  },
  {
    "chapter": "6장",
    "question": "6장-10. 주소 대신에 '의미있는 이름'으로 주기억장치의 위치를 표시한 것은?p15",
    "answer": `정답: 변수(variable)`
  },
  {
    "chapter": "6장",
    "question": "6장-11. 프로그램의 기능을 사람이 이해하도록 자연어로 설명하는 문장은?p14",
    "answer": `정답: 주석(comment)`
  },
  {
    "chapter": "6장",
    "question": "6장-12. 제어문 중에서 반복을 나타내는 구문이 아닌 것은?",
    "answer": `정답 : while: 특정 횟수만큼 명령문들을 반복 실행
                      for: 특정 횟수만큼 명령문들을 반복 실행
                      (내부에서 사용되는 변수 정의, 증감 표현식)
              참고: if: 명령문들을 실행하기 전에 불린 표현식 실행
                    switch: 표현식 실행하고, 결과에 따라 다른 명령문 실행`
              
  },
  {
    "chapter": "6장",
    "question": "6장-13. 다음 for 문에서 본체(body)가 실행되는 횟수는?",
    "answer": `예시없음`
  },
  {
    "chapter": "6장",
    "question": "6장-14. '함수의 입력으로 주어지는 데이터'를 가리키는 용어는?p21",
    "answer": `매개변수: 함수의 입력으로 주어지는 데이터`
  },
  {
    "chapter": "6장",
    "question": "6장-15. 함수 헤더가 정의하는 것이 아닌 것은?p22",
    "answer": ` 함수의 헤더는 함수이름, 세부사항 정의`
  },
  {
    "chapter": "6장",
    "question": "6장-16. 함수의 매개변수 전달 방식 중에, '참조에 의한 전달'은 데이터의 실제주소를 전달하기 때문에 호출 측의 데이터는 변화가 없다?p22",
    "answer": `정답: x(변화가 있다.)
            참고 =>  전달 방식    / 전달하는 것 / 호출 측 데이터
                  값에 의한 전달 / 데이터의 복사본 / 변화 없음
                  참조에 의한 전달 / 데이터의 실제주소 / 변화 있음`
  },
  {
    "chapter": "6장",
    "question": "6장-17. 함수 중에서 결과값을 반환하지 않는 함수를 가리키는 용어는?p23",
    "answer": `정답: 프로시저(procedure) : 반환하지않는함수(void 키워드)`
  },
  {
    "chapter": "6장",
    "question": "6장-18. 객체지향 프로그램의 개념 중에서, '객체 구성에 사용되는 틀(template)'은?p26",
    "answer": `정답: 클래스(class): `
  },
  {
    "chapter": "6장",
    "question": "6장-19. 객체지향 프로그램의 개념 중에서, '객체가 다양한 메시지에 대해 어떻게 반응해야 할지를 기술한 것'은p26",
    "answer": `정답: 매서드`
  },
  {
    "chapter": "6장",
    "question": "6장-20. '생성자'에 대한 설명으로 틀린 것은?p27",
    "answer": `•객체가 처음 생성될 때 객체의 초기화에 사용되는 특별한 메서드
              •클래스 이름과 동일한 이름을 갖는 메서드로 정의
              •클래스의 객체가 생성될 때 자동으로 실행`
  },
  {
    "chapter": "6장",
    "question": "6장-21. '이미 정의되어 있는 클래스'를 활용하여 새로운 클래스를 정의할 수 있게 해주는 객체지향 개념은?p28",
    "answer": `정답: 상속(inheritance)`
  },
  {
    "chapter": "6장",
    "question": "6장-22. 병렬 프로그래밍에서, 한 번에 한 프로세스만이 데이터에 접근할 수 있도록 보장하는 방법과 관련되지 않은 것은?p31",
    "answer": `•세마포어(Semaphore): 제어플래그(flag)로 공유자원의 할당 여부표현(지정, 해제)
                •임계구역(Critical Region): 한번에 한 프로세스만이 실행시킬 수 있는 명령 그룹(공유자원사용)
                •상호배제(Mutual exclusion): 한번에 하나의 프로세스만이 임계구역을 실행하도록 허용하자는 요구사항`
  },
  {
    "chapter": "8장",
    "question": "8장-1. 항목들이 '모두 동일한 타입'인 데이터 블록으로, 각 원소의 위치를 인덱스로 표시하는 것은?p6",
    "answer": `정답: 배열(array)`
  },
  {
    "chapter": "8장",
    "question": "8장-2. 아래 배열에서 인덱스가 7인 값은?p6",
    "answer": `예시 없음
            •배열의 인덱스는 0부터 시작`
  },
  {
    "chapter": "8장",
    "question": "8장-3. 다음 배열은 몇 차원인가?p8",
    "answer": `예시 없음
            • 1차원 배열: 하나의 행으로 이루어짐
            • 2차원 배열: 행들과 열들로 이루어짐(1차원 배열의 집합)
            • 3차원 배열: 2차원 배열의 집합`
  },
  {
    "chapter": "8장",
    "question": "8장-4. '타입과 크기가 다를 수 있는' 데이터 항목들의 블록으로, 각 항목은 필드(field)라고 불리는 자료구조는?p11",
    "answer": `정답: 구조체(structure)`
  },
  {
    "chapter": "8장",
    "question": "8장-5. 가장 보편적인 데이터 추상화로, 항목을 '순차적으로 배열'하는 데이터 집합은?p13",
    "answer": `정답: 리스트(list)`
  },
  {
    "chapter": "8장",
    "question": "8장-6. 항목들에 대한 제거와 삽입이 마지막 원소쪽에서만 이루어지는 리스트는?p17",
    "answer": `정답: 스택(stack)`
  },
  {
    "chapter": "8장",
    "question": "8장-7. 스택에서 가장 최근 항목을 가리키는 변수는 (a)이고, 가장 오래된 항목을 가리키는 변수는 (b)이다. a,b에 해당하는 변수는?",
    "answer": `-(a): 상단(top)  (b): 하단(bottom)`
  },
  {
    "chapter": "8장",
    "question": "8장-8. 스택은 맨 마지막에 들어간 원소가 맨 처음으로 출력된다. 이를 영어약자로 표현하면?p17",
    "answer": `정답:  LIFO: Last-in-first-out`
  },
  {
    "chapter": "8장",
    "question": "8장-9. 한쪽 끝에서 삽입이 일어나고, 그 반대쪽 끝에서 삭제가 일어나는 순서 리스트는?p21",
    "answer": `정답: 큐(queue)`
  },
  {
    "chapter": "8장",
    "question": "8장-10. 큐에서 가장 최근 항목을 가리키는 변수는 (a)이고, 가장 오래된 항목을 가리키는 변수는 (b)이다. a,b에 해당하는 변수는?",
    "answer": `(a): 리어(rear)  (b): 프론트(front)`
  },
  {
    "chapter": "8장",
    "question": "8장-11. 큐는 맨 처음에 들어간 원소가 맨 처음으로 출력된다. 이를 영어약자로 표현하면?p21",
    "answer": `정답: FIFO: First-in-first-out`
  },
  {
    "chapter": "8장",
    "question": "8장-12. 항목들이 계층적 구성을 갖는 데이터 집합으로, 상위 원소에서 하위 원소로 내려가면서 확장되는 나무 모양의 자료구조는?p24",
    "answer": `정답: 트리(tree)`
  },
  {
    "chapter": "8장",
    "question": "8장-13. 아래 트리에서 '상범' 값을 가진 노드의 형제는?",
    "answer": `예시 없음`
  },
  {
    "chapter": "8장",
    "question": "8장-14. 데이터 항목이 저장된 '주소'를 값으로 갖는 변수는?p34",
    "answer": `정답: 포인터(pointer)`
  },
  {
    "chapter": "8장",
    "question": "8장-15. 다음 그림이 설명하는 자료구조는?",
    "answer": `예시 없음`
  },
  {
    "chapter": "8장",
    "question": "8장-16. 행(row) 우선 순서/열(column) 우선 순서로 메모리에 저장되는 자료구조는?p40",
    "answer": `정답: 배열–n차원배열`
  },
  {
    "chapter": "8장",
    "question": "8장-17. 다양한 타입의 필드로 표현되는 자료구조는?p11",
    "answer": `구조체(structure)`
  },
  {
    "chapter": "8장",
    "question": "8장-18. 연결 리스트에 새 노드를 삽입하는 연산의 순서는?",
    "answer": `예시없음`
  },
  {
    "chapter": "8장",
    "question": "8장-19. 이진트리를 배열로 표현한 경우, D 노드가 들어갈 공간의 인덱스는?",
    "answer": `예시없음`
  },
  {
    "chapter": "8장",
    "question": "8장-20. 이진 트리의 검색 알고리즘에서, ?에 들어가야 할 값은?",
    "answer": `예시없음`
  },
  {
    "chapter": "8장",
    "question": "8장-21. 다음 이진 트리에서 H를 검색하기 위해 탐색할 노드의 최단 경로를 순차적으로 표현하면?",
    "answer": `예시없음`
  }
]